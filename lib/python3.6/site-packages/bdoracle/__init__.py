#!/usr/bin/env python
# -*- coding: utf-8 -*-
import requests
import json
import traceback
import time
import os
import sys
from PIL import Image
import io
from io import BytesIO

os.environ["NLS_LANG"] = ".AL32UTF8"

import cx_Oracle

class Orabd():
	"""docstring for orabd"""

# Regresa la cadena de conexión a la BD de Oracle
	def conexion(self):
		return cx_Oracle.connect(self.conectionName)

# Funcion para verificar si el usuario existe en nuestra base de datos, si no existe lo agrega, return json {"nombre": "Antonio", "apPaterno": "Salmeron Tkd", "apMaterno": "None"}
	def validaUsuario(self, idUsuario, token_page=None):
		try:
			cursor = self.con.cursor()
			cursor.prepare("SELECT * FROM TAUSUARIOS WHERE FINOIDFACEBOOK = :idUser")
			result = cursor.execute(None, {'idUser': idUsuario})
			result_list = result.fetchall()
			nombre = ""
			apPaterno = ""
			apMaterno = ""
			if result.rowcount != 0:
				#print("El usuario existe")
				for row in result_list:  # get data in row
					nombre = str(row[2])
					apPaterno = str(row[3])
					apMaterno = str(row[4])
			else :
				#print("El usuario no existe")
				userTempData = self.obtenerDatosPublicos(idUsuario,token_page)
				if len(userTempData) > 0: #El usuario puede tener privado sus datos personales {}
					nombre = userTempData['first_name']
					apPaterno = userTempData['last_name']
				cursorinsert = self.con.cursor()
				cursorinsert.prepare("INSERT INTO TAUSUARIOS(FINOIDFACEBOOK, FCNOMBRE, FCAPPATERNO) VALUES (:idUser, :nombre, :apPaterno)")
				cursorinsert.execute(None, {'idUser': idUsuario, 'nombre': nombre, 'apPaterno': apPaterno})
				self.con.commit()
			data = {"nombre": nombre, "apPaterno": apPaterno, "apMaterno": apMaterno}
			data = json.dumps(data)  
			return json.loads(data)  
		except cx_Oracle.DatabaseError as e:
			error, = e.args
			self.cathErrores(error.code, "Validar usuario: " + error.message)
		except Exception:
			traceback.print_exc(file=sys.stdout)


# Regresa el estado anterior y el actual, si no existe lo agrega como estado 10, json {"fechaModificado": "2017-05-02 16:02:53", "estAnterior": 10, "estActual": 10, "extras": "None"}
	def consultaEstado(self, idUsuario):
		try:
			cursor = self.con.cursor()
			cursor.prepare("SELECT FDFECHA, FIESTANTERIOR, FIESTACTUAL, FCTIPO FROM TAESTADOS WHERE FINOIDFACEBOOK = :idUser")
			result = cursor.execute(None, {'idUser': idUsuario})
			result_list = result.fetchall()
			fechModificado = self.getFechaHora()
			estAnterior = 10
			estActual = 10
			tipo = "L"
			if result.rowcount != 0:
				print("Existen estados")
				for row in result_list:  # get data in row
					fechModificado = str(row[0])
					estAnterior = row[1]
					estActual = row[2]
					tipo = str(row[3])
			else :
				print("No existen estados")
				cursorinsert = self.con.cursor()
				cursorinsert.prepare("INSERT INTO TAESTADOS VALUES (seidestados.nextval, TO_DATE(:fecha ,'DD/MM/YYYY HH24:MI:SS'), :estAnterior, :estActual, :idUser, :tipo)")
				cursorinsert.execute(None, {"fecha": fechModificado, "estAnterior": estAnterior, "estActual": estActual, "tipo": tipo, "idUser": idUsuario})
				self.con.commit()
			data = {"fechaModificado": fechModificado, "estAnterior": estAnterior, "estActual": estActual, "tipo": tipo}
			data = json.dumps(data)  
			return json.loads(data)
		except cx_Oracle.DatabaseError as e:
			error, = e.args
			self.cathErrores(error.code, "Consulta Estado: " + error.message)
		except Exception:
			traceback.print_exc(file=sys.stdout)

# Actualiza el campo al siguiente estado, retorna Boolean
	def updateEstado(self, idUsuario, estSiguiente, tipo=None):
		try:
			fechModificado = self.getFechaHora()
			cursorinsert = self.con.cursor()
			cursorinsert.prepare("INSERT INTO TTESTACTUAL VALUES(:idUser, TO_DATE(:fecha ,'DD/MM/YYYY HH24:MI:SS'), :estActual, :tipo)")
			cursorinsert.execute(None, {"idUser": idUsuario, "fecha": fechModificado, "estActual": estSiguiente, "tipo": tipo})
			self.con.commit()
			return True
		except cx_Oracle.DatabaseError as e:
			error, = e.args
			self.cathErrores(error.code, "Update Estado: " + error.message)
		except Exception:
			traceback.print_exc(file=sys.stdout)


# Actualiza la información básica del usuario, retorna Boolean
	def updateNombreUsuario(self, idUsuario, nombre, apPaterno=None, apMaterno=None):
		try:
			cursorupdate = self.con.cursor()
			cursorupdate.prepare("UPDATE TAUSUARIOS SET FCNOMBRE = :nombre, FCAPPATERNO = :apPaterno, FCAPMATERNO = :apMaterno WHERE FINOIDFACEBOOK = :idUser")
			cursorupdate.execute(None, {"nombre": nombre, "apPaterno": apPaterno, "apMaterno": apMaterno, "idUser": idUsuario})
			self.con.commit()
			return True
		except cx_Oracle.DatabaseError as e:
			error, = e.args
			self.cathErrores(error.code, "Update Nombre Usuario: " + error.message)
			return False
		except Exception:
			traceback.print_exc(file=sys.stdout)
			return False

# Actualiza el ID de cliente del remitente, retorna Boolean
	def updateIdClienteUsuario(self, idUsuario, idCliente):
		try:
			cursorupdate = self.con.cursor()
			cursorupdate.prepare("UPDATE TAUSUARIOS SET FINOIDCLIENTE = :idCliente WHERE FINOIDFACEBOOK = :idUser")
			cursorupdate.execute(None, {"idCliente": idCliente, "idUser": idUsuario})
			self.con.commit()
			return True
		except cx_Oracle.DatabaseError as e:
			error, = e.args
			self.cathErrores(error.code, "Update Cliente Usuario: " + error.message)
			return False
		except Exception:
			traceback.print_exc(file=sys.stdout)
			return False

# Actualiza la fecha de nacimiento del remitente, retorna Boolean
	def updateFechaNacUsuario(self, idUsuario, fechaNac):
		try:
			cursorupdate = self.con.cursor()
			cursorupdate.prepare("UPDATE TAUSUARIOS SET FDFECHANAC = TO_DATE(:fecha ,'DD/MM/YYYY') WHERE FINOIDFACEBOOK = :idUser")
			cursorupdate.execute(None, {"fecha": fechaNac, "idUser": idUsuario})
			self.con.commit()
			return True
		except cx_Oracle.DatabaseError as e:
			error, = e.args
			self.cathErrores(error.code, "Update Fecha Nacimiento Usuario: " + error.message)
			return False
		except Exception:
			traceback.print_exc(file=sys.stdout)
			return False

			return False

# Actualiza telefono del usuario, retorna Boolean
	def updateTelefonoUsuario(self, idUsuario, telefono):
		try:
			cursorupdate = self.con.cursor()
			cursorupdate.prepare("UPDATE TAUSUARIOS SET FITELEFONO = :telefono WHERE FINOIDFACEBOOK = :idUser")
			cursorupdate.execute(None, {"telefono": telefono, "idUser": idUsuario})
			self.con.commit()
			return True
		except cx_Oracle.DatabaseError as e:
			error, = e.args
			self.cathErrores(error.code, "Update Telefono Usuario: " + error.message)
			return False
		except Exception:
			traceback.print_exc(file=sys.stdout)
			return False

# Actualiza el estado de lista negra del usuario, retorna Boolean
	def updateListaNegra(self, idUsuario, listaNegra):
		try:
			cursorupdate = self.con.cursor()
			cursorupdate.prepare("UPDATE TAUSUARIOS SET FIBLOQUEO = :listaNegra WHERE FINOIDFACEBOOK = :idUser")
			cursorupdate.execute(None, {"listaNegra": listaNegra, "idUser": idUsuario})
			self.con.commit()
			return True
		except cx_Oracle.DatabaseError as e:
			error, = e.args
			self.cathErrores(error.code, "Update Lista Negra: " + error.message)
			return False
		except Exception:
			traceback.print_exc(file=sys.stdout)
			return False

# Actualiza la dirección del usuario, retorna Boolean
	def updateDireccionUsuario(self, idUsuario, direccion, cp=None, estado=None, municipio=None, colonia=None):
		try:
			cursorupdate = self.con.cursor()
			cursorupdate.prepare("UPDATE TAUSUARIOS SET FCDIRECCION = :direccion, FICODPOSTAL = :cp, FCESTADO = :estado, FCMUNICIPIO = :municipio, FCCOLONIA = :colonia WHERE FINOIDFACEBOOK = :idUser")
			cursorupdate.execute(None, {"direccion": direccion, "cp":  cp, "estado": estado, "municipio": municipio, "colonia": colonia, "idUser": idUsuario})
			self.con.commit()
			return True
		except cx_Oracle.DatabaseError as e:
			error, = e.args
			self.cathErrores(error.code, "Update Direccion Usuario: " + error.message)
			return False
		except Exception:
			traceback.print_exc(file=sys.stdout)
			return False

# Consulta los datos del usuario, como la direccion, regresa JSON {"idCliente": 12345, "fechaNac": "14/06/1993",, "bloqueo": 0, "telefono": 5520181902, "direccion": "Albires 18", "cp": 54680, "estado": "Mexico", "municipio": "DF", "colonia": "San Miguel"}
	def consultaDatosUsuario(self, idUsuario):
		try:
			cursor = self.con.cursor()
			cursor.prepare("SELECT FINOIDCLIENTE, FCNOMBRE, FCAPPATERNO, FCAPMATERNO, TO_CHAR(FDFECHANAC ,'DD/MM/YYYY'), FIBLOQUEO, FITELEFONO, FCDIRECCION, FICODPOSTAL, FCESTADO, FCMUNICIPIO, FCCOLONIA FROM TAUSUARIOS WHERE FINOIDFACEBOOK = :idUser")
			result = cursor.execute(None, {'idUser': idUsuario})
			result_list = result.fetchall()
			nombre = ""
			apPaterno = ""
			apMaterno = ""
			idCliente = 0
			fechaNac = ""
			bloqueo = 0
			telefono = 0
			direccion = ""
			cp = 0
			estado = ""
			municipio = ""
			colonia = ""
			if result.rowcount != 0:
				for row in result_list:  # get data in row
					idCliente = row[0]
					nombre = str(row[1])
					apPaterno = str(row[2])
					apMaterno = str(row[3])
					fechaNac = str(row[4])
					bloqueo = row[5]
					telefono = row[6]
					direccion = str(row[7])
					cp = row[8]
					estado = str(row[9])
					municipio = str(row[10])
					colonia = str(row[11])
			data = {"idCliente": idCliente, "nombre": nombre, "apPaterno": apPaterno, "apMaterno": apMaterno, "fechaNac": fechaNac, "bloqueo": bloqueo, "telefono": telefono, "direccion": direccion, "cp": cp, "estado": estado, "municipio": municipio, "colonia": colonia}
			return json.loads(json.dumps(data))
		except cx_Oracle.DatabaseError as e:
			error, = e.args
			self.cathErrores(error.code, "Consulta Datos Usuario: " + error.message)
		except Exception:
			traceback.print_exc(file=sys.stdout)

# Agrega a un beneficiario, es necesario consultar servicio de cliente/alta/remitente para tener el idBeneficiario, el telefono no es obligatorio, retorna Boolean
	def addBeneficiario(self, idUsuario, idBeneficiario, nombre, apPaterno, apMaterno, estado, telefono=None):
		try:
			cursorinsert = self.con.cursor()
			cursorinsert.prepare("INSERT INTO TTADDBENEFICIARIO VALUES(:idBeneficiario, :nombre, :apPaterno, :apMaterno, :telefono, :idUsuario, :estado)")
			cursorinsert.execute(None, {"idBeneficiario": idBeneficiario, "nombre": nombre, "apPaterno": apPaterno, "apMaterno": apMaterno, "telefono": telefono, "idUsuario": idUsuario, "estado": estado})
			self.con.commit()
			return True
		except cx_Oracle.DatabaseError as e:
			error, = e.args
			self.cathErrores(error.code, "Add Beneficiario: " + error.message)
			return False
		except Exception:
			traceback.print_exc(file=sys.stdout)
			return False
			
# Consulta todos los beneficiarios, retorna JSON Object [{"idBeneficiario": 1, "nombre": "Antonio", "apPaterno": "Santiago", "apMaterno": "Chepox", "telefono": "None"}, {"idBeneficiario": 2, "nombre": "Pepe", "apPaterno": "Pecas", "apMaterno": "Chepox", "telefono": "None"}]
	def consultaBeneficiarios(self, idUsuario):
		try:
			cursor = self.con.cursor()
			cursor.prepare("SELECT B.FINOBENEFICIARIO, B.FCNOMBRE, B.FCAPPATERNO, B.FCAPMATERNO, B.FITELEFONO, E.FCNOMBRE FROM TABENEFICIARIOS B INNER JOIN TAMAPESTADOS E ON B.FIESTADOID = E.FIESTADOID WHERE b.FINOIDFACEBOOK = :idUser AND B.FIACTIVO = 1")			
			result = cursor.execute(None, {'idUser': idUsuario})
			result_list = result.fetchall()
			data = []
			if result.rowcount != 0:
				for row in result_list:  # get data in row
					idBeneficiario = row[0]
					nombre = str(row[1])
					apPaterno = str(row[2])
					apMaterno = str(row[3])
					telefono = row[4]
					info = {"idBeneficiario": idBeneficiario, "nombre": nombre, "apPaterno": apPaterno, "apMaterno": apMaterno, "telefono": telefono}
					data.append(info)
			return json.loads(json.dumps(data))
		except cx_Oracle.DatabaseError as e:
			error, = e.args
			self.cathErrores(error.code, "Consulta Beneficiarios: " + error.message)
		except Exception:
			traceback.print_exc(file=sys.stdout)

# Consulta todos los beneficiarios, retorna JSON Object {"idBeneficiario": 1, "nombre": "Antonio", "apPaterno": "Santiago", "apMaterno": "Chepox", "telefono": "None"}
	def consultaUnBeneficiario(self, idUsuario, idBeneficiario):
		try:
			cursor = self.con.cursor()
			cursor.prepare("SELECT B.FINOBENEFICIARIO, B.FCNOMBRE, B.FCAPPATERNO, B.FCAPMATERNO, B.FITELEFONO, E.FCNOMBRE FROM TABENEFICIARIOS B INNER JOIN TAMAPESTADOS E ON B.FIESTADOID = E.FIESTADOID WHERE (B.FINOBENEFICIARIO = :idBeneficiario AND B.FINOIDFACEBOOK = :idUser) AND B.FIACTIVO = 1")
			result = cursor.execute(None, {'idBeneficiario': idBeneficiario, "idUser": idUsuario})
			result_list = result.fetchall()
			data = {}
			if result.rowcount != 0:
				for row in result_list:  # get data in row
					idBeneficiario = row[0]
					nombre = str(row[1])
					apPaterno = str(row[2])
					apMaterno = str(row[3])
					telefono = row[4]
					estado = str(row[5])
					data = {"idBeneficiario": idBeneficiario, "nombre": nombre, "apPaterno": apPaterno, "apMaterno": apMaterno, "telefono": telefono, "estado": estado}
			return json.loads(json.dumps(data))
		except cx_Oracle.DatabaseError as e:
			error, = e.args
			self.cathErrores(error.code, "Consulta Un Beneficiario: " + error.message)
		except Exception:
			traceback.print_exc(file=sys.stdout)

# Elimina a un beneficiario, se necesita el idde beneficiario y el id del usuario, retorna Boolean
	def eliminaBeneficiario(self, idUsuario, idBeneficiario):
		try:
			cursorupdate = self.con.cursor()
			cursorupdate.prepare("UPDATE TABENEFICIARIOS SET FIACTIVO = 0 WHERE FINOBENEFICIARIO = :idBeneficiario AND FINOIDFACEBOOK = :idUser")
			cursordelete.execute(None, {"idBeneficiario": idBeneficiario, "idUser": idUsuario})
			self.con.commit()
			return True
		except cx_Oracle.DatabaseError as e:
			error, = e.args
			self.cathErrores(error.code, "Elimina Beneficiario: " + error.message)
			return False
		except Exception:
			traceback.print_exc(file=sys.stdout)
			return False

# Agrega a un Pre beneficiario, esta funcion debe ser temporal para almacenar datos del beneficiaro por el flujo
	def addPreBeneficiario(self, idUser, nombre, apPaterno, apMaterno, telefono=None):
		try:
			cursorinsert = self.con.cursor()
			cursorinsert.prepare("INSERT INTO TAPREBENEFICIARIOS VALUES(:idUser, :nombre, :apPaterno, :apMaterno, :telefono)")
			cursorinsert.execute(None, {"idUser": idUser, "nombre": nombre, "apPaterno": apPaterno, "apMaterno": apMaterno, "telefono": telefono})
			self.con.commit()
			return True
		except cx_Oracle.DatabaseError as e:
			error, = e.args
			self.cathErrores(error.code, "Add Pre Beneficiario: " + error.message)
			return False
		except Exception:
			traceback.print_exc(file=sys.stdout)
			return False


# Consulta consecutivo para generar uid regresa JSON {"uid": 0}
	def generaUid(self):
		try:
			cursor = self.con.cursor()
			result = cursor.execute("SELECT 'UID' || 9559 || LPAD(SEUIDCONSECUTIVO.NEXTVAL, 8, '0')  FROM DUAL")
			result_list = result.fetchall()
			data = 0
			if result.rowcount != 0:
				for row in result_list:  # get data in row
					consecutivo = row[0]
			data = {"uid": consecutivo}
			return json.loads(json.dumps(data))
		except cx_Oracle.DatabaseError as e:
			error, = e.args
			self.cathErrores(error.code, "Genera UID: " + error.message)
		except Exception:
			traceback.print_exc(file=sys.stdout)

# Agrega transferencia, es necesario ejecutar servicio envio/genera, retorna Boolean
	def addEnvio(self, fcuid, folio, tarifa, descuentoCF, monto, saldoAbonado, tcfx, descuentoCupon, claveSeguridad, montoTotal, montoEnvioMg, referenciaPreEnvio, idBeneficiario, codigo, mensaje):
		try:
			cursorinsert = self.con.cursor()
			cursorinsert.prepare("INSERT INTO TTFOLIOS VALUES(:fcuid, :folio, :tarifa, :descuentoCF, :monto, :saldoAbonado, :tcfx, :descuentoCupon, :claveSeguridad, :montoTotal, :montoEnvioMg, :referenciaPreEnvio, :idBeneficiario, :codigo, :mensaje)")
			cursorinsert.execute(None, {"fcuid": fcuid, "folio": folio, "tarifa": tarifa, "descuentoCF": descuentoCF, "monto": monto, "saldoAbonado": saldoAbonado, "tcfx": tcfx, "descuentoCupon": descuentoCupon, "claveSeguridad": claveSeguridad, "montoTotal": montoTotal, "montoEnvioMg": montoEnvioMg, "referenciaPreEnvio": referenciaPreEnvio, "idBeneficiario": idBeneficiario, "codigo": codigo, "mensaje": mensaje})
			self.con.commit()
			return True;
		except cx_Oracle.DatabaseError as e:
			error, = e.args
			self.cathErrores(error.code, "Add Envio: " + error.message)
			return False
		except Exception:
			traceback.print_exc(file=sys.stdout)
			return False

# Actualiza el estado del envío, folio expirado, folio cobrado , etc. retorna Boolean
	def updateEnvio(self, folio, codigo, mensaje):
		try:
			cursorinsert = self.con.cursor()
			cursorinsert.prepare("INSERT INTO TTUPDATEENVIO VALUES(:folio, :codigo, :mensaje)")
			cursorinsert.execute(None, {"folio": folio, "codigo": codigo, "mensaje": mensaje})
			self.con.commit()
			return True;
		except cx_Oracle.DatabaseError as e:
			error, = e.args
			self.cathErrores(error.code, "Update Envio: " + error.message)
			return False
		except Exception:
			traceback.print_exc(file=sys.stdout)
			return False

# Actualiza la localización del GPS, cuando el usuario envía su posición actual, retorna Boolean
	def updateLocalizacion(self, folio, latitud, longitud):
		try:
			cursorupdate = self.con.cursor()
			cursorupdate.prepare("UPDATE TATRANSACCIONES SET FILATITUDE = :latitud, FILONGITUDE = :longitud WHERE FIFOLIO = :folio")
			cursorupdate.execute(None, {"latitud": latitud, "longitud":  longitud, "folio": folio})
			self.con.commit()
			return True
		except cx_Oracle.DatabaseError as e:
			error, = e.args
			self.cathErrores(error.code, "Update Localización: " + error.message)
			return False
		except Exception:
			traceback.print_exc(file=sys.stdout)
			return False

# Captura errores, regresa Boolean
	def cathErrores(self, codigo, error):
		try:
			fecha = self.getFechaHora()
			cursorinsert = self.con.cursor()
			cursorinsert.prepare("INSERT INTO TAERRORES VALUES(SEIDERRORES.NEXTVAL, TO_DATE(:fecha ,'DD/MM/YYYY HH24:MI:SS'), :codigo, :error)")
			cursorinsert.execute(None, {"fecha": fecha, "codigo": codigo, "error": error})
			self.con.commit()
			return True
		except Exception:
			traceback.print_exc(file=sys.stdout)
			return False

# Agrega un extra, retorna Boolean
	def addExtra(self, idUser, clave, valor):
		try:
			cursorinsert = self.con.cursor()
			cursorinsert.prepare("INSERT INTO TAEXTRAS VALUES(:idUsuario, :clave, :valor)")
			cursorinsert.execute(None, {"idUsuario": idUser, "clave": clave, "valor": valor})
			self.con.commit()
			return True
		except cx_Oracle.DatabaseError as e:
			error, = e.args
			self.cathErrores(error.code, "Add Extra: " + error.message)
			return False
		except Exception:
			traceback.print_exc(file=sys.stdout)
			return False

# Consulta todos los extras, retorna JSON Object [{"idBeneficiario": "1234"}, {"monto": "500"}, {"otros": "ABC"}]
	def consultaExtras(self, idUsuario):
		try:
			cursor = self.con.cursor()
			cursor.prepare("SELECT FCCLAVE, FCVALOR FROM TAEXTRAS WHERE FINOIDFACEBOOK = :idUsuario")
			result = cursor.execute(None, {'idUsuario': idUsuario})
			result_list = result.fetchall()
			data = {}
			if result.rowcount != 0:
				for row in result_list:  # get data in row
					clave = str(row[0])
					valor = str(row[1])
					data[clave] = valor
			return json.loads(json.dumps(data))
		except cx_Oracle.DatabaseError as e:
			error, = e.args
			self.cathErrores(error.code, "Consulta Extras: " + error.message)
		except Exception:
			traceback.print_exc(file=sys.stdout)

# Elimina los extras, se recomienda usarlo al finalizar el flujo completo del chatbot, retorna Boolean
	def eliminaExtras(self, idUsuario):
		try:
			cursordelete = self.con.cursor()
			cursordelete.prepare("DELETE FROM TAEXTRAS WHERE FINOIDFACEBOOK = :idUsuario")
			cursordelete.execute(None, {"idUsuario": idUsuario})
			self.con.commit()
			return True
		except cx_Oracle.DatabaseError as e:
			error, = e.args
			self.cathErrores(error.code, "Elimina Extras: " + error.message)
			return False
		except Exception:
			traceback.print_exc(file=sys.stdout)
			return False
			
# Actualiza el valor de un extra, retorna Boolean
	def updateExtra(self, idUsuario, clave, nuevoValor):
		try:
			cursorupdate = self.con.cursor()
			cursorupdate.prepare("UPDATE TAEXTRAS SET FCVALOR = :valor WHERE FINOIDFACEBOOK = :iduser AND FCCLAVE = :clave")
			cursorupdate.execute(None, {"valor": nuevoValor, "iduser": idUsuario, "clave": clave})
			self.con.commit()
			return True
		except cx_Oracle.DatabaseError as e:
			error, = e.args
			self.cathErrores(error.code, "Update Extra: " + error.message)
			return False
		except Exception:
			traceback.print_exc(file=sys.stdout)
			return False
			
# Consulta el estado y municipios a partir de un código postal, regresa JSON Object
	def consultaCodigoPostal(self, codigoPostal):
		try:
			cursor = self.con.cursor()
			cursor.prepare("SELECT FCCP, FCMUNICIPIO, FCNOMBRE FROM TAMAPCPOSTAL INNER JOIN TAMAPESTADOS ON FIIDESTADO = FIESTADOID WHERE FCCP = :cp")
			result = cursor.execute(None, {'cp': codigoPostal})
			result_list = result.fetchall()
			data = []
			if result.rowcount != 0:
				print("Existen datos")
				for row in result_list:  # get data in row
					cp = str(row[0])
					municipio = str(row[1])
					estado = str(row[2])
					info = {"cp": cp, "municipio": municipio, "estado": estado}
					data.append(info)
			return json.loads(json.dumps(data))
		except cx_Oracle.DatabaseError as e:
			error, = e.args
			self.cathErrores(error.code, "Consulta CP: " + error.message)
		except Exception:
			traceback.print_exc(file=sys.stdout)


	def obtenerDatosPublicos(self, idSender, token_page):
		try:
			# Obtiene datos publicos de usuario
			# TODO cambiar token
			TOKEN = token_page
			userResponse = requests.get('https://graph.facebook.com/v2.6/' + str(idSender) + '?fields=first_name,last_name,profile_pic,locale,timezone,gender&access_token=' + TOKEN)
			return json.loads(userResponse.text)
		except Exception:
			traceback.print_exc(file=sys.stdout)

	def getFechaHora(self):
		try:
			fecha = time.strftime("%d/%m/%Y")
			hora = time.strftime("%H:%M:%S")
			return fecha + " " + hora
		except Exception:
			traceback.print_exc(file=sys.stdout)

	def __init__(self):
		self.conectionName = 'USRCHATBOT/CHATBOT@192.168.12.239:1521/CDBORCL'
		self.con = self.conexion()








