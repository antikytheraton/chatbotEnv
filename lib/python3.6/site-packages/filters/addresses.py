#! /usr/bin/python
# -*- coding: utf-8 -*-

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import re

zip_regex = re.compile('\d{5}')
faux_zip_regex = re.compile('\d{6,}')
zip_head_regex = re.compile('(C\.?P\.?)|ZIP(CODE)?')
num_regex = re.compile('\d|([S]\.?/?[N]\.?)')
col_regex = re.compile('COL(\.|ONIA)?')
col2_regex = re.compile('COL(\.|ONIA)')
mun_regex = re.compile('DEL(\.|EGACI[OÓ]N)?')
mun2_regex = re.compile('DEL(\.|EGACI[OÓ]N)')
col_mun_head_lengths = [3,4,7,10]
preps_regex = re.compile('D(EL?|I)|L(A|OS)|EN')


def process_address(address):
    """Given a (Mexican, Spanish) address,
    splits it into the most likely gen_address, zip_code combination.
    gen_address typically has a street, street number, city name, and/or
    neighborhood, and/or country.
    zip_code is a 5-digit numeric value.
    :return dict:
    {'calle_num': street_and_number,
    'codigo_postal': zip_code,
    'lista_colonias': cols,
    'lista_delegaciones': muns,
    'unk': ' '.join(tokens)}
    If zip_code is not found, then a None value is returned as second argument.
    Raises a ValueError if an empty string is passed.
    """
    if address == '':
        raise ValueError('A valid address cannot be an empty string!!')

    puncts = ',:;'
    filter1 = ''.join([s for s in address if s not in puncts])
    tokens = filter1.strip().upper().split()

    # find zip code
    zip_code = None
    zip_index = -1
    for i in reversed(range(len(tokens))):
        if not faux_zip_regex.match(tokens[i]):
            match = zip_regex.search(tokens[i])
            if match:
                zip_code = match.group(0)
                zip_index = i
                break

    # remove zip_code
    if not zip_code:
        print('Zip code not found!!')
    else:
        tokens = tokens[:zip_index] + tokens[zip_index+1:]
        tokens = [x for x in filter(lambda a: not zip_head_regex.match(a), tokens)]


    # find street and number
    street_and_number = ''
    num_index = zip_index - 1 if zip_index >= 0 else len(tokens)
    for i in reversed(range(len(tokens))):
        match = num_regex.search(tokens[i])
        if match:
            num_index = i + 1
            break

    # remove street and number
    street_and_number = ' '.join(tokens[:num_index])
    tokens = tokens[num_index:]

    # find neighboorhood (colonia) and municipalty
    cols = []
    muns = []
    acc = ''
    matches_mun = [mun_regex.match(word) is not None and
                   len(word) in col_mun_head_lengths for word in tokens]
    matches_col = [col_regex.match(word) is not None and
                   len(word) in col_mun_head_lengths for word in tokens]
    matches2_mun = [mun2_regex.match(word) is not None for word in tokens]
    matches2_col = [col2_regex.match(word) is not None for word in tokens]
    if True in matches_col:
        match_index = matches2_col.index(True) if True in matches2_col else matches_col.index(True)
        for token in tokens[matches_col.index(True)+1:]:
            acc += token + ' '
            cols.append(acc[:-1])
        tokens = tokens[:match_index] + tokens[match_index+1:]
    elif True in matches_mun:
        match_index = matches_mun.index(True)
        trimmed = tokens[:match_index]\
                  + (tokens[match_index+2:] if match_index + 2 < len(tokens) else [])
        for token in trimmed:
            acc += token + ' '
            cols.append(acc[:-1])
    else:
        for i in range(len(tokens)):
            acc = ''
            for token in tokens[i:]:
                acc += token + ' '
                cols.append(acc[:-1])

    if True in matches_mun:
        match_index = matches2_mun.index(True) if True in matches2_mun else matches_mun.index(True)
        acc = ''
        for token in tokens[match_index:]:
            acc += token + ' '
            muns.append(acc[:-1])
        tokens = tokens[:match_index] + tokens[match_index+1:]
    else:
        for i in range(len(tokens)):
            acc = ''
            for token in tokens[i:]:
                acc += token + ' '
                muns.append(acc[:-1])

    dico = {'calle_num': street_and_number,
            'codigo_postal': zip_code,
            'lista_colonias': cols,
            'lista_delegaciones': muns,
            'unk': ' '.join(tokens)}
    return dico


if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser(description='script\'s argument parser')
    parser.add_argument('d', help='address')
    args = parser.parse_args()
    print(process_address(args.d))
    with open('addresses.txt', 'r') as f:
          for ad in f:
              parsed = process_address(ad)
              for p in parsed:
                  print(p)
              print('---')