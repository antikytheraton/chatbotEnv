#! /usr/bin/python
# -*- coding: utf-8 -*-
from datetime import datetime
import re, json
import _pickle as cPickle

class FilterDate():
	def Splitdia(fecha):

		tokens = fecha.split(" ")
		names = []

		especial_tokens = ["de","del","a","-","/"]

		mes_numer={"ENERO":"01","FEBRERO":"02","MARZO":"03","ABRIL":"04","MAYO":"05",
		"JUNIO":"06","JULIO":"07","AGOSTO":"08","SEPTIEMBRE":"09","OCTUBRE":"10",
		"NOVIEMBRE":"11","DICIEMBRE":"12"}
		prev = ""

		for token in tokens:
			_token = token.lower()

			if _token in especial_tokens:
				prev += token + " "
			else:
				names.append(token)
				prev = ""
		
		num_dia = len(names)
		dia,mes,ano = "","",""

		if num_dia == 0:
			dia = ""

		elif num_dia == 1:
			dia = names[0]

		elif num_dia == 2:
			dia = names[0]
			mes = names[1]

		elif num_dia == 3:
			dia = names[0]
			mes = names[1]
			ano = names[2]

		else:
			dia = names[0] + " " + names [1]
			mes = names[2]
			ano = names[3]

		try:
			fecha_date = datetime.strptime(fecha,"%d/%m/%Y")
			return fecha
		except:

			try:	
				dia = int(dia.upper())
				mes = mes.upper()
				ano = int(ano.upper())
				
				for key,value in mes_numer.items():
					if key == mes:
						mes = int(value)
					
				hoy = datetime(ano,mes,dia)
				formato_mes = "%d/%m/%Y"
				fecha = hoy.strftime(formato_mes)		

				return fecha
			except:
				return False

class FilterNames():
	def SplitNombres(nombre):

		tokens = nombre.split(" ")
		names = []

		especial_tokens = ["da","de","di","do","del","la","las","le","los",
		"y","san"]

		prev = ""

		for token in tokens:
			_token = token.lower()

			if _token in especial_tokens:
				prev += token + " "
			else:
				names.append(prev + token)
				prev = ""
		
		num_nombres = len(names)
		nombre,appelido1,appelido2 = "","",""

		if num_nombres == 0:
			nombres = ""

		elif num_nombres == 1:
			nombres = names[0]

		elif num_nombres == 2:
			nombres = names[0]
			appelido1 = names[1]

		elif num_nombres == 3:
			nombres = names[0]
			appelido1 = names[1]
			appelido2 = names[2]

		else:
			nombres = names[0] + " " + names [1]
			appelido1 = names[2]
			appelido2 = names[3]

		nombres = nombres.title()
		appelido1 = appelido1.title()
		appelido2 = appelido2.title()

		return [nombres,appelido1,appelido2]

class FilterQuantity():
	def validate(num):
		try:
			num = FilterQuantity.eliminate_words(num.lower())
			if  int(num) >= 20 and int(num) <= 1000:
				num = num.replace(" ","")
				return [True, num]
			else:
				return [False, '0']
		except:
			return FilterQuantity.validate(FilterQuantity.word2int(num))

	def word2int(textnum, numwords={}):
		try:
			if not numwords:
				units = [
				"cero", "uno", "dos", "tres", "cuatro", "cinco", "seis", "siete", "ocho",
				"nueve", "diez", "once", "doce", "trece", "catorce", "quince",
				"dieciseis", "diecisiete", "dieciocho", "diecinueve",
				]

				tens = ["", "", "veinte", "treinta", "cuarenta", "cincuenta", "sesenta", "setenta", "ochenta", "noventa"]

				scales = ["","ciento","doscientos","trescientos","cuatrocientos","quinientos","siescientos","setecientos","ochocientos","novecientos", "mil"]

				numwords["y"] = (1, 0)
				for idx, word in enumerate(units):    numwords[word] = (1, idx)
				for idx, word in enumerate(tens):     numwords[word] = (1, idx * 10)
				for idx, word in enumerate(scales):   numwords[word] = (1, idx * 100)

			current = result = 0
			for word in textnum.split():
				if word =="cien":
					return str(100)
				else:
					if word not in numwords:
						return False

					scale, increment = numwords[word]
					current = current * scale + increment
					if scale > 100:
						result += current
						current = 0
			return str(result + current)
		except:
			return '0'

	def eliminate_words(string_input):
		string_input = string_input.replace("$","")
		string_input = string_input.replace("pesos","")
		string_input = string_input.replace("varos","")
		return string_input


class FilterAddress():
	def process_address(address):
		zip_regex = re.compile('\d{5}')
		faux_zip_regex = re.compile('\d{6,}')
		zip_head_regex = re.compile('(C\.?P\.?)|ZIP(CODE)?')
		num_regex = re.compile('\d|([S]\.?/?[N]\.?)')
		col_regex = re.compile('COL(\.|ONIA)?')
		mun_regex = re.compile('DEL(\.|EGACI[OÃ“]N)?')
		col_mun_head_lengths = [3,4,7,10]
		preps_regex = re.compile('D(EL?|I)|L(A|OS)|EN')
		if address == '':
			raise ValueError('A valid address cannot be an empty string!!')

		puncts = ',:;'
		filter1 = ''.join([s for s in address if s not in puncts])
		tokens = filter1.strip().upper().split()

		# find zip code
		zip_code = None
		zip_index = -1
		for i in reversed(range(len(tokens))):
			if not faux_zip_regex.match(tokens[i]):
				match = zip_regex.search(tokens[i])
				if match:
					zip_code = match.group(0)
					zip_index = i
					break

		# remove zip_code
		if not zip_code:
			print('Zip code not found!!')
		else:
			tokens = tokens[:zip_index] + tokens[zip_index+1:]
			tokens = [x for x in filter(lambda a: not zip_head_regex.match(a), tokens)]

	    # find street and number
		street_and_number = ''
		num_index = zip_index - 1 if zip_index >= 0 else len(tokens)
		for i in reversed(range(len(tokens))):
			match = num_regex.search(tokens[i])
			if match:
				num_index = i + 1
				break

		# remove street and number
		street_and_number = ' '.join(tokens[:num_index])
		tokens = tokens[num_index:]

		# find neighboorhood (colonia) and municipalty
		cols = []
		muns = []
		acc = ''
		matches_mun = [mun_regex.match(word) is not None and
						len(word) in col_mun_head_lengths for word in tokens]
		matches_col = [col_regex.match(word) is not None and
						len(word) in col_mun_head_lengths for word in tokens]
		index_mun = matches_mun.index(True) if True in matches_mun else len(tokens)
		index_col = matches_col.index(True) if True in matches_col else len(tokens)
		if index_mun < index_col:
			mun = tokens[index_mun+1 : index_col]
			col = tokens[index_col+1:]
		else:
			mun = tokens[index_mun+1:]
			col = tokens[index_col+1: index_mun]
		tokens = [x for x in filter(lambda a: not mun_regex.match(a) or not col_regex.match(a), tokens)]
		dico = {'calle_num': street_and_number,
	            'codigo_postal': zip_code,
	            'colonia': ' '.join(col),
	            'delegacion': ' '.join(mun),
	            'unk': ' '.join(tokens)}
		dico = json.dumps(dico)  
		return json.loads(dico)

class FilterGreetings():
	def getResponse(text):
		cl = cPickle.load( open( "classifier.pickle", "rb" ) )
		textClass = cl.classify(text.lower())
		if textClass == 'creador':
			return 0
		elif textClass == 'saludo':
			return 1
		else :
			return 2
			pass
		pass


